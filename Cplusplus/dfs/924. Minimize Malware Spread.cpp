// 924. Minimize Malware Spread
// Hard

// 108

// 79

// Favorite

// Share
// In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.

// Some nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware,
//  both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.

// Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.

// We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial). 
//  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.

// Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.
                   
 

// Example 1:

// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
// Output: 0
// Example 2:

// Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
// Output: 0
// Example 3:

// Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
// Output: 1
 

// Note:

// 1 < graph.length = graph[0].length <= 300
// 0 <= graph[i][j] == graph[j][i] <= 1
// graph[i][i] = 1
// 1 <= initial.length < graph.length
// 0 <= initial[i] < graph.length

#include<vector>
using namespace std;
class Solution {
private:
    vector<int> f;
    vector<int> ct;
    int find(int a){
        if(f[a] == a) return a;
        return f[a] = find(f[a]);
    }
    void union_find(int a , int b){
        int rootA = find(a);
        int rootB = find(b);
        if(rootA != rootB){
            f[rootB] = rootA;
            ct[rootA]++;
        }
    }
    void dfs(vector<vector<int>>& graph , int s , vector<bool>& visited){
        for(int i = 0 ; i < graph[s].size() ; ++i){
            if(s != i && graph[s][i] == 1 && !visited[i]){
                visited[i] = true;
                union_find(s , i);
                dfs(graph , i , visited);
            }
        }
    }
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<bool> visited(n, false);
        f = vector<int>(n , 0);
        ct = vector<int>(n , 0);
        for(int i = 0 ; i < n ; i++){
            f[i] = i;
        }
        
        for(int i = 0 ; i < n ; i++){
            visited[i] = true;
            dfs(graph , i , visited);
        }
        
        int res = -1;
        int max = 0;
        int root = -1;
        sort(initial.begin() , initial.end());
        for(int node : initial){
            if(f[node] == root){
                max = 0;     
            }
            else if(ct[f[node]] > max){
                max = ct[f[node]];
                res = node;
                root = f[node];
            }       
        }
        return res == -1 ? initial[0] : res;
        
    }
};



/// union find  1. mark all the forest scale and root , then find the node with max root with no duplication
// class Solution {
//     private int find(int a){
//         if(f[a] == a) return a;
//         return f[a] = find(f[a]);
//     }
    
//     private void union(int a , int b){
//         int rootA = find(a);
//         int rootB = find(b);
//         if(rootA != rootB){
//             f[rootB] = rootA;
//             ct[rootA]++;
//         }
//     }
    
//     int[] f;
//     int[] ct;
//     public int minMalwareSpread(int[][] graph, int[] initial) {
//         int n  = graph.length;
//         f = new int[n];
//         ct = new int[n];
//         for(int i = 0 ; i < n ; i++) f[i] = i;
        
//         boolean[] visited = new boolean[n];
//         for(int i = 0 ; i < n ; i++){
//             visited[i] = true;
//             dfs(graph , i , visited);
//         }        
//         int res = -1;
//         int max = 0;
//         int root = -1;
//         Arrays.sort(initial);
//         for(int node : initial){
//             if(f[node] == root){
//                 max = 0;     
//             }
//             else if(ct[f[node]] > max){
//                 max = ct[f[node]];
//                 res = node;
//                 root = f[node];
//             }       
//         }
//         return res == -1 ? initial[0] : res;
//     }
//     private void dfs(int[][] graph , int s , boolean[] visited){
//         for(int i = 0 ; i < graph[s].length ; i++){
//             if(s != i && graph[s][i] == 1 && !visited[i]){
//                 union(s , i);
//                 visited[i] = true;
//                 dfs(graph , i , visited);
//             }
//         }
//     }
// }